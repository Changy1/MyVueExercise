<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<style>

</style>
<body>
    <div id="app">
        <h1>Number: {{num}}</h1>
        <p><button @click="num++">++</button></p>
        <h2>Number的二倍为: {{num * 2}}</h2>

        <!-- <h2>Number乘以67，再加上138，再减去64，再平方....为: {{ computeNumber() }}</h2>
        <p>Number乘以67，再加上138，再减去64，再平方....为:{{  computeNumber() }}</p>
        <h3>Number乘以67，再加上138，再减去64，再平方....为:{{  computeNumber() }}</h3> -->

        <h2>Number乘以67，再加上138，再减去64，再平方....为: {{ num_result }}</h2>
        <p>Number乘以67，再加上138，再减去64，再平方....为:{{  num_result }}</p>
        <h3>Number乘以67，再加上138，再减去64，再平方....为:{{  num_result }}</h3>
        <input type="number" v-model = "num_result">
        <hr>

    </div>

    <script src="./base/vue.js"></script>
    <script>
        // 在vue中可以利用计算属性 来 根据当前已有的某个数据 来按照某些条件 派生/衍生出 一条新的数据，当现有数据变化，新数据也会变化
        
        new Vue({
            el: '#app',
            data: {
                num: 0,
            },
            computed: {
               /*  num_result: function () {   //这样写不能直接去改变num_result的值，会报错，因为data里面并没有results
                    return this.num*2
                } */
                num_result: {
                    get () {
                        return this.num*2
                    },
                    set (val) {
                        this.num = val/2
                    }
                }
            }
        })


        // 当我们需要再视图上显示大量运算之后的结果的时候，为了方便更新和维护
        // 1. 可以封装methods方法，视图上显示方法的返回值, 缺点: 计算次数多，而且会受到无关数据的影响

        // 2. 可以利用watch监听的方式来完成，需要在data中定义新数据，增加了使用成本，其实watch专业的在监听数据变化后去干什么什么事儿
        //    当数据变化后，做一些特殊的事情

        // 目前我们想要实现的时候，当num数据变化后，能有一条新的数据来使用

        //  3. 可以利用计算数据来根据当前数据派生新数据，会自动执行一次，当当前数据变化的时候会重新计算

   

      
    </script>
</body>
</html>